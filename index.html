<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drowsiness Detector - Real-time Monitoring</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.13.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/blazeface@0.0.7/dist/blazeface.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/face-landmarks-detection@0.0.3/dist/face-landmarks-detection.min.js"></script>
    <style>
        .alert-sound {
            display: none;
        }
        .blink {
            animation: blink-animation 0.5s infinite;
        }
        @keyframes blink-animation {
            0% { background-color: rgba(239, 68, 68, 0.2); }
            50% { background-color: rgba(239, 68, 68, 0.8); }
            100% { background-color: rgba(239, 68, 68, 0.2); }
        }
        .gauge {
            width: 100%;
            height: 10px;
            background-color: #374151;
            border-radius: 5px;
            overflow: hidden;
        }
        .gauge-fill {
            height: 100%;
            transition: width 0.3s ease;
        }
        .settings-panel {
            transform: translateX(100%);
            transition: transform 0.3s ease;
        }
        .settings-panel.open {
            transform: translateX(0);
        }
        .fade-in {
            animation: fadeIn 0.5s;
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
    </style>
</head>
<body class="bg-gray-900 text-white font-sans min-h-screen">
    <div class="container mx-auto px-4 py-6">
        <header class="flex justify-between items-center mb-6">
            <h1 class="text-2xl font-bold flex items-center">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 mr-2 text-red-500" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" />
                </svg>
                Drowsiness Detector
            </h1>
            <div class="flex items-center">
                <div id="status-indicator" class="h-4 w-4 rounded-full bg-gray-400 mr-2"></div>
                <span id="status-text" class="text-sm">Initializing...</span>
            </div>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
            <!-- Main video feed -->
            <div class="lg:col-span-2 bg-gray-800 rounded-lg overflow-hidden shadow-lg relative">
                <div id="video-container" class="relative w-full" style="height: 480px;">
                    <video id="webcam" class="w-full h-full object-cover" autoplay playsinline></video>
                    <canvas id="overlay" class="absolute top-0 left-0 w-full h-full"></canvas>
                    <div id="alert-banner" class="absolute top-0 left-0 w-full h-full flex items-center justify-center hidden">
                        <div class="bg-red-500 bg-opacity-70 p-4 rounded-lg text-white text-xl font-bold">
                            WAKE UP! Drowsiness Detected
                        </div>
                    </div>
                </div>
                <div class="p-4 bg-gray-700 flex justify-between items-center">
                    <div>
                        <button id="start-btn" class="bg-green-500 hover:bg-green-600 text-white px-4 py-2 rounded-lg flex items-center">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z" />
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                            </svg>
                            Start Monitoring
                        </button>
                    </div>
                    <div>
                        <button id="settings-btn" class="bg-gray-600 hover:bg-gray-500 text-white px-4 py-2 rounded-lg flex items-center">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                            </svg>
                            Settings
                        </button>
                    </div>
                </div>
            </div>

            <!-- Stats dashboard -->
            <div class="bg-gray-800 rounded-lg shadow-lg p-6">
                <h2 class="text-xl font-bold mb-4">Detection Dashboard</h2>
                
                <div class="mb-6">
                    <div class="flex justify-between items-center mb-2">
                        <span class="text-sm text-gray-400">Drowsiness Score</span>
                        <span id="drowsiness-value" class="text-sm font-bold">0%</span>
                    </div>
                    <div class="gauge">
                        <div id="drowsiness-gauge" class="gauge-fill bg-red-500" style="width: 0%"></div>
                    </div>
                </div>
                
                <div class="mb-6">
                    <div class="flex justify-between items-center mb-2">
                        <span class="text-sm text-gray-400">Blink Rate (per minute)</span>
                        <span id="blink-rate" class="text-sm font-bold">0</span>
                    </div>
                    <div class="gauge">
                        <div id="blink-gauge" class="gauge-fill bg-blue-500" style="width: 0%"></div>
                    </div>
                </div>

                <div class="mb-6">
                    <div class="flex justify-between items-center mb-2">
                        <span class="text-sm text-gray-400">Eye Closure Duration</span>
                        <span id="eye-closure" class="text-sm font-bold">0.0s</span>
                    </div>
                    <div class="gauge">
                        <div id="closure-gauge" class="gauge-fill bg-yellow-500" style="width: 0%"></div>
                    </div>
                </div>

                <div class="bg-gray-700 p-4 rounded-lg">
                    <h3 class="font-bold mb-2">Statistics</h3>
                    <div class="grid grid-cols-2 gap-4">
                        <div>
                            <div class="text-sm text-gray-400">Monitoring Time</div>
                            <div id="monitoring-time" class="text-xl font-bold">00:00:00</div>
                        </div>
                        <div>
                            <div class="text-sm text-gray-400">Alerts Triggered</div>
                            <div id="alert-count" class="text-xl font-bold">0</div>
                        </div>
                        <div>
                            <div class="text-sm text-gray-400">Detection Status</div>
                            <div id="detection-status" class="text-xl font-bold text-green-500">Ready</div>
                        </div>
                        <div>
                            <div class="text-sm text-gray-400">FPS</div>
                            <div id="fps-counter" class="text-xl font-bold">0</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Settings panel (slide-in) -->
        <div id="settings-panel" class="settings-panel absolute top-0 right-0 h-full w-80 bg-gray-800 shadow-lg p-6 z-10">
            <div class="flex justify-between items-center mb-6">
                <h2 class="text-xl font-bold">Settings</h2>
                <button id="close-settings" class="text-gray-400 hover:text-white">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                    </svg>
                </button>
            </div>

            <div class="space-y-6">
                <div>
                    <label class="block text-sm text-gray-400 mb-2">Drowsiness Sensitivity</label>
                    <input id="drowsiness-sensitivity" type="range" min="1" max="10" value="5" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                    <div class="flex justify-between text-xs text-gray-500 mt-1">
                        <span>Low</span>
                        <span>High</span>
                    </div>
                </div>

                <div>
                    <label class="block text-sm text-gray-400 mb-2">Alert Threshold (seconds)</label>
                    <input id="alert-threshold" type="range" min="1" max="5" step="0.5" value="2.5" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                    <div class="flex justify-between text-xs text-gray-500 mt-1">
                        <span>1.0s</span>
                        <span>5.0s</span>
                    </div>
                </div>

                <div class="flex items-center">
                    <input id="enable-sound" type="checkbox" checked class="h-4 w-4 text-blue-600 rounded border-gray-700 focus:ring-blue-500">
                    <label for="enable-sound" class="ml-2 text-sm text-gray-400">Enable Alert Sound</label>
                </div>

                <div class="flex items-center">
                    <input id="show-landmarks" type="checkbox" class="h-4 w-4 text-blue-600 rounded border-gray-700 focus:ring-blue-500">
                    <label for="show-landmarks" class="ml-2 text-sm text-gray-400">Show Face Landmarks</label>
                </div>

                <div>
                    <label class="block text-sm text-gray-400 mb-2">Camera Source</label>
                    <select id="camera-select" class="bg-gray-700 border border-gray-600 text-white rounded-lg block w-full p-2.5">
                        <option value="">Loading cameras...</option>
                    </select>
                </div>

                <button id="reset-settings" class="w-full bg-gray-700 hover:bg-gray-600 text-white px-4 py-2 rounded-lg mt-4">
                    Reset to Defaults
                </button>
            </div>
        </div>
    </div>

    <!-- Alert sound -->
    <audio id="alert-sound" preload="auto">
        <source src="https://cdn.jsdelivr.net/npm/web-alert-sounds@1.0.0/sounds/alarm.mp3" type="audio/mpeg">
    </audio>

    <script>
        // Global variables
        let model = null;
        let faceLandmarksModel = null;
        let isRunning = false;
        let video = null;
        let canvas = null;
        let ctx = null;
        let monitoring = null;
        let monitoringStartTime = null;
        let alertCount = 0;
        let lastBlinkTime = 0;
        let blinkCount = 0;
        let blinkRates = [];
        let eyesClosed = false;
        let eyeClosureStartTime = 0;
        let longClosureDuration = 0;
        let drowsinessScore = 0;
        let frameCount = 0;
        let lastFpsUpdateTime = 0;
        let fps = 0;
        let cameraDevices = [];
        
        // Settings - default values
        let settings = {
            drowsinessSensitivity: 5,
            alertThreshold: 2.5,
            enableSound: true,
            showLandmarks: false,
            selectedCamera: ''
        };

        // Initialize the application
        async function init() {
            updateStatus('Loading models...', 'bg-yellow-500');
            
            try {
                // Load the face detection model
                model = await blazeface.load();
                
                // Load the face landmarks model
                faceLandmarksModel = await faceLandmarksDetection.load(
                    faceLandmarksDetection.SupportedPackages.mediapipeFacemesh,
                    { maxFaces: 1 }
                );
                
                // Setup webcam
                video = document.getElementById('webcam');
                canvas = document.getElementById('overlay');
                ctx = canvas.getContext('2d');
                
                // Enumerate available cameras
                await enumerateCameras();
                
                // Set up event listeners
                setupEventListeners();
                
                // Update UI
                updateStatus('Ready', 'bg-green-500');
                
                // Adjust canvas size to match video
                window.addEventListener('resize', adjustCanvasSize);
            } catch (error) {
                console.error('Initialization error:', error);
                updateStatus('Error: ' + error.message, 'bg-red-500');
            }
        }
        
        // Enumerate available cameras
        async function enumerateCameras() {
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                cameraDevices = devices.filter(device => device.kind === 'videoinput');
                
                const cameraSelect = document.getElementById('camera-select');
                cameraSelect.innerHTML = '';
                
                if (cameraDevices.length === 0) {
                    cameraSelect.innerHTML = '<option value="">No cameras found</option>';
                    return;
                }
                
                cameraDevices.forEach((device, index) => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    option.text = device.label || `Camera ${index + 1}`;
                    cameraSelect.appendChild(option);
                });
                
                // Set default camera
                if (cameraDevices.length > 0) {
                    settings.selectedCamera = cameraDevices[0].deviceId;
                    cameraSelect.value = settings.selectedCamera;
                }
            } catch (error) {
                console.error('Error enumerating cameras:', error);
            }
        }
        
        // Setup webcam with selected device
        async function setupWebcam() {
            try {
                const constraints = {
                    video: {
                        deviceId: settings.selectedCamera ? { exact: settings.selectedCamera } : undefined,
                        width: { ideal: 640 },
                        height: { ideal: 480 },
                        facingMode: 'user'
                    }
                };
                
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = stream;
                
                return new Promise((resolve) => {
                    video.onloadedmetadata = () => {
                        adjustCanvasSize();
                        resolve();
                    };
                });
            } catch (error) {
                console.error('Error accessing webcam:', error);
                updateStatus('Camera Error: ' + error.message, 'bg-red-500');
                throw error;
            }
        }
        
        // Adjust canvas size to match video dimensions
        function adjustCanvasSize() {
            if (video.videoWidth && video.videoHeight) {
                const videoContainer = document.getElementById('video-container');
                const containerWidth = videoContainer.clientWidth;
                const containerHeight = videoContainer.clientHeight;
                
                // Maintain aspect ratio
                const videoAspect = video.videoWidth / video.videoHeight;
                const containerAspect = containerWidth / containerHeight;
                
                let width, height;
                if (containerAspect > videoAspect) {
                    height = containerHeight;
                    width = height * videoAspect;
                } else {
                    width = containerWidth;
                    height = width / videoAspect;
                }
                
                canvas.width = width;
                canvas.height = height;
            }
        }
        
        // Start monitoring
        async function startMonitoring() {
            if (isRunning) return;
            
            try {
                // Setup webcam if not already running
                await setupWebcam();
                
                isRunning = true;
                document.getElementById('start-btn').textContent = 'Stop Monitoring';
                document.getElementById('start-btn').classList.remove('bg-green-500', 'hover:bg-green-600');
                document.getElementById('start-btn').classList.add('bg-red-500', 'hover:bg-red-600');
                
                updateStatus('Monitoring Active', 'bg-green-500');
                monitoringStartTime = Date.now();
                lastFpsUpdateTime = Date.now();
                frameCount = 0;
                
                // Start the detection loop
                requestAnimationFrame(detectFrame);
                
                // Start the timer for monitoring duration
                updateMonitoringTime();
                monitoring = setInterval(updateMonitoringTime, 1000);
            } catch (error) {
                console.error('Error starting monitoring:', error);
                updateStatus('Error: ' + error.message, 'bg-red-500');
                isRunning = false;
            }
        }
        
        // Stop monitoring
        function stopMonitoring() {
            if (!isRunning) return;
            
            isRunning = false;
            document.getElementById('start-btn').textContent = 'Start Monitoring';
            document.getElementById('start-btn').classList.remove('bg-red-500', 'hover:bg-red-600');
            document.getElementById('start-btn').classList.add('bg-green-500', 'hover:bg-green-600');
            
            updateStatus('Monitoring Stopped', 'bg-yellow-500');
            
            clearInterval(monitoring);
            hideAlert();
            
            // Clear webcam stream tracks
            if (video.srcObject) {
                video.srcObject.getTracks().forEach(track => track.stop());
                video.srcObject = null;
            }
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
        
        // Main detection loop
        async function detectFrame() {
            if (!isRunning) return;
            
            try {
                // Update FPS counter
                frameCount++;
                const now = Date.now();
                const elapsed = now - lastFpsUpdateTime;
                
                if (elapsed >= 1000) {
                    fps = Math.round((frameCount * 1000) / elapsed);
                    document.getElementById('fps-counter').textContent = fps;
                    frameCount = 0;
                    lastFpsUpdateTime = now;
                }
                
                // Detect faces
                const predictions = await model.estimateFaces(video, false);
                
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                if (predictions.length > 0) {
                    // Face detected
                    updateDetectionStatus('Active', 'text-green-500');
                    
                    // Get face landmarks for more precise eye detection
                    const landmarks = await faceLandmarksModel.estimateFaces({
                        input: video
                    });
                    
                    if (landmarks.length > 0) {
                        const face = landmarks[0];
                        processEyeState(face);
                        
                        if (settings.showLandmarks) {
                            drawFaceLandmarks(face);
                        } else {
                            // Draw simple face box
                            const scaleFactor = {
                                width: canvas.width / video.videoWidth,
                                height: canvas.height / video.videoHeight
                            };
                            
                            const prediction = predictions[0];
                            const start = prediction.topLeft;
                            const end = prediction.bottomRight;
                            const size = [end[0] - start[0], end[1] - start[1]];
                            
                            ctx.strokeStyle = '#00ff00';
                            ctx.lineWidth = 2;
                            ctx.strokeRect(
                                start[0] * scaleFactor.width,
                                start[1] * scaleFactor.height,
                                size[0] * scaleFactor.width,
                                size[1] * scaleFactor.height
                            );
                        }
                    }
                } else {
                    // No face detected
                    updateDetectionStatus('No Face', 'text-red-500');
                }
                
                // Request next frame
                requestAnimationFrame(detectFrame);
            } catch (error) {
                console.error('Detection error:', error);
                updateDetectionStatus('Error', 'text-red-500');
                
                // Try to continue
                requestAnimationFrame(detectFrame);
            }
        }
        
        // Process eye state (open/closed)
        function processEyeState(face) {
            // Extract eye landmarks
            const leftEye = face.keypoints.filter(point => 
                (point.name && point.name.includes('leftEye')) || 
                (point.name === undefined && point.index >= 130 && point.index <= 159)
            );
            
            const rightEye = face.keypoints.filter(point => 
                (point.name && point.name.includes('rightEye')) || 
                (point.name === undefined && point.index >= 160 && point.index <= 189)
            );
            
            if (leftEye.length && rightEye.length) {
                // Calculate eye aspect ratio (EAR) to determine if eyes are closed
                const leftEAR = calculateEAR(leftEye);
                const rightEAR = calculateEAR(rightEye);
                const ear = (leftEAR + rightEAR) / 2;
                
                // Draw eye state
                drawEyeState(leftEye, rightEye, ear);
                
                // Detect blinks and handle drowsiness
                const earThreshold = 0.2 - (settings.drowsinessSensitivity - 5) * 0.01;
                
                if (ear < earThreshold) {
                    // Eyes closed
                    if (!eyesClosed) {
                        eyesClosed = true;
                        eyeClosureStartTime = Date.now();
                    } else {
                        const closureDuration = (Date.now() - eyeClosureStartTime) / 1000;
                        document.getElementById('eye-closure').textContent = closureDuration.toFixed(1) + 's';
                        document.getElementById('closure-gauge').style.width = Math.min(closureDuration * 20, 100) + '%';
                        
                        // Update drowsiness score based on closure duration
                        longClosureDuration = closureDuration;
                        updateDrowsinessScore();
                        
                        // Check for drowsiness alert threshold
                        if (closureDuration > settings.alertThreshold) {
                            triggerAlert();
                        }
                    }
                } else {
                    // Eyes open
                    if (eyesClosed) {
                        eyesClosed = false;
                        const closureDuration = (Date.now() - eyeClosureStartTime) / 1000;
                        
                        // Count as blink if closure was brief
                        if (closureDuration < 0.5) {
                            blinkCount++;
                            lastBlinkTime = Date.now();
                            updateBlinkRate();
                        }
                        
                        // Reset eye closure duration
                        document.getElementById('eye-closure').textContent = '0.0s';
                        document.getElementById('closure-gauge').style.width = '0%';
                        
                        // Gradually reduce drowsiness score when eyes are open
                        setTimeout(() => {
                            longClosureDuration = Math.max(0, longClosureDuration - 0.5);
                            updateDrowsinessScore();
                        }, a500);
                        
                        // Hide alert if it was showing
                        hideAlert();
                    }
                }
            }
        }
        
        // Calculate Eye Aspect Ratio (EAR)
        function calculateEAR(eyePoints) {
            // Simplified EAR calculation for mediapipe landmarks
            // Find the eye height (vertical distance)
            let maxY = -Infinity, minY = Infinity;
            let sumX = 0, sumY = 0;
            
            eyePoints.forEach(point => {
                maxY = Math.max(maxY, point.y);
                minY = Math.min(minY, point.y);
                sumX += point.x;
                sumY += point.y;
            });
            
            // Average position (center of eye)
            const centerX = sumX / eyePoints.length;
            const centerY = sumY / eyePoints.length;
            
            // Calculate average distance from center to points (approximates width)
            let totalDist = 0;
            eyePoints.forEach(point => {
                const dx = point.x - centerX;
                const dy = point.y - centerY;
                totalDist += Math.sqrt(dx*dx + dy*dy);
            });
            
            const avgRadius = totalDist / eyePoints.length;
            const height = maxY - minY;
            
            // EAR is approximated as height divided by width
            return height / (avgRadius * 2);
        }
        
        // Draw eye state on canvas
        function drawEyeState(leftEye, rightEye, ear) {
            const scaleFactor = {
                width: canvas.width / video.videoWidth,
                height: canvas.height / video.videoHeight
            };
            
            // Function to get average eye position
            function getEyeCenter(eyePoints) {
                let sumX = 0, sumY = 0;
                eyePoints.forEach(point => {
                    sumX += point.x;
                    sumY += point.y;
                });
                return {
                    x: sumX / eyePoints.length,
                    y: sumY / eyePoints.length
                };
            }
            
            const leftCenter = getEyeCenter(leftEye);
            const rightCenter = getEyeCenter(rightEye);
            
            // Draw circles around eyes
            ctx.lineWidth = 2;
            
            // Determine color based on eye state
            const earThreshold = 0.2 - (settings.drowsinessSensitivity - 5) * 0.01;
            if (ear < earThreshold) {
                ctx.strokeStyle = '#ff0000'; // Red for closed eyes
            } else {
                ctx.strokeStyle = '#00ff00'; // Green for open eyes
            }
            
            // Find average radius
            let avgRadius = 0;
            leftEye.forEach(point => {
                const dx = point.x - leftCenter.x;
                const dy = point.y - leftCenter.y;
                avgRadius += Math.sqrt(dx*dx + dy*dy);
            });
            avgRadius = (avgRadius / leftEye.length) * 1.5; // Slightly larger circle
            
            // Draw circles
            ctx.beginPath();
            ctx.arc(
                leftCenter.x * scaleFactor.width,
                leftCenter.y * scaleFactor.height,
                avgRadius * scaleFactor.width,
                0, 2 * Math.PI
            );
            ctx.stroke();
            
            ctx.beginPath();
            ctx.arc(
                rightCenter.x * scaleFactor.width,
                rightCenter.y * scaleFactor.height,
                avgRadius * scaleFactor.width,
                0, 2 * Math.PI
            );
            ctx.stroke();
            
            // Display EAR value
            ctx.fillStyle = '#ffffff';
            ctx.font = '14px Arial';
            ctx.fillText(
                `EAR: ${ear.toFixed(2)}`,
                10,
                30
            );
        }
        
        // Draw face landmarks
        function drawFaceLandmarks(face) {
            const scaleFactor = {
                width: canvas.width / video.videoWidth,
                height: canvas.height / video.videoHeight
            };
            
            // Draw all landmarks
            ctx.fillStyle = 'rgba(0, 255, 0, 0.5)';
            face.keypoints.forEach(point => {
                ctx.beginPath();
                ctx.arc(
                    point.x * scaleFactor.width,
                    point.y * scaleFactor.height,
                    1,
                    0, 2 * Math.PI
                );
                ctx.fill();
            });
            
            // Draw eyes with a different color
            ctx.fillStyle = 'rgba(0, 0, 255, 0.7)';
            const eyePoints = face.keypoints.filter(point => 
                (point.name && (point.name.includes('leftEye') || point.name.includes('rightEye'))) || 
                (point.name === undefined && ((point.index >= 130 && point.index <= 159) || (point.index >= 160 && point.index <= 189)))
            );
            
            eyePoints.forEach(point => {
                ctx.beginPath();
                ctx.arc(
                    point.x * scaleFactor.width,
                    point.y * scaleFactor.height,
                    2,
                    0, 2 * Math.PI
                );
                ctx.fill();
            });
        }
        
        // Update blink rate
        function updateBlinkRate() {
            // Calculate blinks per minute
            const now = Date.now();
            const oneMinuteAgo = now - 60000;
            
            // Clean up old blink rates
            blinkRates = blinkRates.filter(time => time > oneMinuteAgo);
            blinkRates.push(now);
            
            const blinksPerMinute = blinkRates.length;
            document.getElementById('blink-rate').textContent = blinksPerMinute;
            
            // Update gauge (normal blink rate is around 15-20 per minute)
            const blinkRatePercent = Math.min(100, (blinksPerMinute / 20) * 100);
            document.getElementById('blink-gauge').style.width = blinkRatePercent + '%';
            
            // Low blink rate can indicate drowsiness
            if (blinksPerMinute < 10) {
                drowsinessScore = Math.min(100, drowsinessScore + 5);
                updateDrowsinessUI();
            }
        }
        
        // Update drowsiness score
        function updateDrowsinessScore() {
            // Calculate drowsiness based on eye closure duration and blink rate
            const maxClosureFactor = 50; // Maximum contribution from eye closure
            const closureFactor = Math.min(maxClosureFactor, longClosureDuration * 20);
            
            // Calculate blink rate factor (low blink rate increases drowsiness)
            const blinkRateFactor = blinkRates.length < 10 ? 30 - (blinkRates.length * 3) : 0;
            
            // Combine factors with sensitivity adjustment
            const sensitivityFactor = (settings.drowsinessSensitivity / 5);
            drowsinessScore = Math.min(100, (closureFactor + blinkRateFactor) * sensitivityFactor);
            
            updateDrowsinessUI();
        }
        
        // Update drowsiness UI
        function updateDrowsinessUI() {
            document.getElementById('drowsiness-value').textContent = Math.round(drowsinessScore) + '%';
            document.getElementById('drowsiness-gauge').style.width = drowsinessScore + '%';
            
            // Change color based on drowsiness level
            const drowsinessGauge = document.getElementById('drowsiness-gauge');
            if (drowsinessScore < 30) {
                drowsinessGauge.classList.remove('bg-yellow-500', 'bg-red-500');
                drowsinessGauge.classList.add('bg-green-500');
            } else if (drowsinessScore < 60) {
                drowsinessGauge.classList.remove('bg-green-500', 'bg-red-500');
                drowsinessGauge.classList.add('bg-yellow-500');
            } else {
                drowsinessGauge.classList.remove('bg-green-500', 'bg-yellow-500');
                drowsinessGauge.classList.add('bg-red-500');
            }
        }
        
        // Trigger alert
        function triggerAlert() {
            const alertBanner = document.getElementById('alert-banner');
            
            if (!alertBanner.classList.contains('blink')) {
                alertBanner.classList.remove('hidden');
                alertBanner.classList.add('blink');
                
                document.getElementById('video-container').classList.add('blink');
                
                // Play alert sound if enabled
                if (settings.enableSound) {
                    const alertSound = document.getElementById('alert-sound');
                    alertSound.play().catch(error => console.error('Error playing alert sound:', error));
                }
                
                // Increment alert count
                alertCount++;
                document.getElementById('alert-count').textContent = alertCount;
            }
        }
        
        // Hide alert
        function hideAlert() {
            const alertBanner = document.getElementById('alert-banner');
            alertBanner.classList.add('hidden');
            alertBanner.classList.remove('blink');
            
            document.getElementById('video-container').classList.remove('blink');
            
            // Stop alert sound
            const alertSound = document.getElementById('alert-sound');
            alertSound.pause();
            alertSound.currentTime = 0;
        }
        
        // Update status indicator
        function updateStatus(message, colorClass) {
            const statusIndicator = document.getElementById('status-indicator');
            const statusText = document.getElementById('status-text');
            
            // Remove all color classes
            statusIndicator.classList.remove('bg-gray-400', 'bg-green-500', 'bg-yellow-500', 'bg-red-500');
            
            // Add the new color class
            statusIndicator.classList.add(colorClass);
            
            // Update text
            statusText.textContent = message;
        }
        
        // Update detection status
        function updateDetectionStatus(status, colorClass) {
            const detectionStatus = document.getElementById('detection-status');
            
            // Remove all color classes
            detectionStatus.classList.remove('text-green-500', 'text-yellow-500', 'text-red-500');
            
            // Add the new color class
            detectionStatus.classList.add(colorClass);
            
            // Update text
            detectionStatus.textContent = status;
        }
        
        // Update monitoring time
        function updateMonitoringTime() {
            if (!monitoringStartTime) return;
            
            const elapsed = Date.now() - monitoringStartTime;
            const seconds = Math.floor((elapsed / 1000) % 60).toString().padStart(2, '0');
            const minutes = Math.floor((elapsed / (1000 * 60)) % 60).toString().padStart(2, '0');
            const hours = Math.floor((elapsed / (1000 * 60 * 60)) % 24).toString().padStart(2, '0');
            
            document.getElementById('monitoring-time').textContent = `${hours}:${minutes}:${seconds}`;
        }
        
        // Setup event listeners
        function setupEventListeners() {
            // Start/stop button
            document.getElementById('start-btn').addEventListener('click', function() {
                if (isRunning) {
                    stopMonitoring();
                } else {
                    startMonitoring();
                }
            });
            
            // Settings button
            document.getElementById('settings-btn').addEventListener('click', function() {
                document.getElementById('settings-panel').classList.add('open');
            });
            
            // Close settings
            document.getElementById('close-settings').addEventListener('click', function() {
                document.getElementById('settings-panel').classList.remove('open');
            });
            
            // Drowsiness sensitivity slider
            document.getElementById('drowsiness-sensitivity').addEventListener('input', function(e) {
                settings.drowsinessSensitivity = parseInt(e.target.value);
            });
            
            // Alert threshold slider
            document.getElementById('alert-threshold').addEventListener('input', function(e) {
                settings.alertThreshold = parseFloat(e.target.value);
            });
            
            // Enable sound checkbox
            document.getElementById('enable-sound').addEventListener('change', function(e) {
                settings.enableSound = e.target.checked;
            });
            
            // Show landmarks checkbox
            document.getElementById('show-landmarks').addEventListener('change', function(e) {
                settings.showLandmarks = e.target.checked;
            });
            
            // Camera select
            document.getElementById('camera-select').addEventListener('change', function(e) {
                settings.selectedCamera = e.target.value;
                if (isRunning) {
                    stopMonitoring();
                    startMonitoring();
                }
            });
            
            // Reset settings
            document.getElementById('reset-settings').addEventListener('click', function() {
                document.getElementById('drowsiness-sensitivity').value = 5;
                document.getElementById('alert-threshold').value = 2.5;
                document.getElementById('enable-sound').checked = true;
                document.getElementById('show-landmarks').checked = false;
                
                settings.drowsinessSensitivity = 5;
                settings.alertThreshold = 2.5;
                settings.enableSound = true;
                settings.showLandmarks = false;
            });
            
            // Handle click outside settings panel to close it
            document.addEventListener('click', function(e) {
                const settingsPanel = document.getElementById('settings-panel');
                const settingsBtn = document.getElementById('settings-btn');
                
                if (!settingsPanel.contains(e.target) && e.target !== settingsBtn && !settingsBtn.contains(e.target)) {
                    settingsPanel.classList.remove('open');
                }
            });
        }
        
        // Initialize the application when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>
